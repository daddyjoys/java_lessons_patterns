#Collections
## Queue
Очередь - это очень интересный тип хранения данных. Мы можем проводить с ней ограниченное количество операций - обычно только с верхним элементом, и не имеем доступа к "середине" очереди.
<br />Мы не можем ничего вставить в середину очереди - только в конец.
> PriorityQueue

Что интересного в PriorityQueue? Дело в том, что элементы в ней располагаются не только по порядку, но и по приоритету. Этот приоритет можно задавать самостоятельно.
<br />Eсли создавать очередь из стандартных типов данных (Integer, Float, String), у нее будет стандартный приоритет:
<br /> - для чисел по возрастанию
<br /> - для строк по алфавиту

>FIFO и LIFO в Java

FIFO (First in first out) - Переводится как "первый пришел первый вышел".
<br />Пример: оередь за чем либо
<br /><br />LIFO (Last in first out) - последний пришел первый вышел
<br />Пример: Стопка тарелок. первой положил - посленей взял
<br />
>Операции с Queue
1. add() - добавляет элемент в конец очереди.
<br /> Поправка: если очередь с приоритетом - т.е. PriorityQueue - элемент ставится не обязательно в конец, а в соответствии со своим приоритетом
2. remove() и poll() - удаляет верхний элемент из очереди.  
Remove на пустой очереди вызовет exception, а poll - нет.
3. offer() - пытается вставить элемент в конец очереди.
4. peek() и element() - показывают верхний элемент очереди


## Set
>Чем отличаются HashSet, LinkedHashSet и TreeSet

<b>HashSet</b> хранит элементы в произвольном порядке, но зато быстро ищет. Подходит, если порядок Вам не важен, но важна скорость. Более того, для оптимизации поиска, HashSet будет хранить элементы так, как ему удобно.
<br/><b>LinkedHashSet</b> будет хранить элементы в порядке добавления, но зато работает медленнее.
<br/><b>TreeSet</b> хранит элементы отсортированными.

<code>HashSet<String> myHashSet = new HashSet<String>();</code>

>Операции с множествами
1. add() - добавляет элемент в множество
2. remove() - удаляет элемент из множества
3. contains() - определяет, есть ли элемент в множестве
4. size() - возвращает размер множества
5. clear() - удаляет все элементы из коллекции
6. isEmpty() - возвращает true если множество пустое, и false если там есть хотя бы 1 элемент

# Map
HashMap - это структура данных которая хранит пары ключ-значения.
<br />Начальное количество корзин в HashMap -16. Но как и с ArrayList-ом в конструкторе можно задать другое количество.

колизия возникает в том случае, когда хешкод одинаковый, но по equals обьекты разные.
Коллизия это когда два разных объекта попадают в одну корзинку(связанный список). Причиной этому служат то что они имеют одинаковый hashcode. Для более эффективной работы с HashMap hashcode не должен повторяться для не эквивалентных объектов.
Как происходит добавление? Первое это мы выясняем то какая корзина соответствует ключу объекта. Затем проверяем есть ли в ней уже какие-то объекты если нет то добавляем текущий. Если да то это случилась коллизия. Тогда мы начинаем сравнивать ключи текущего объекта и тех которые внутри (если конечно их там несколько). Сравнение производится методом equals. Если equals возвращает true значит ключи совпадают, производится замена, новый объект заменяет тот который уже там находится под тем же ключом, если нет новый объект добавляется в конец списка.

Как и когда происходит увеличение количества корзин в HashMap?
У HashMap имеет поле loadFactory. Оно может быть задано через конструктор. По умолчанию равняется 0.75. Для чего оно нужно? Его произведение на количество корзин дает нам необходимое число объектов которое нужно добавить чтобы состоялось удвоение количества корзин.. Например если у нас мапка с 16-ю корзинами, а loadFactory равняется 0.75, то расширение произойдет когда мы добавим 16 * 0.75 = 12 объектов. Мапка увеличивается вдвое.
https://vk.com/topic-68704273_30860442

>Существует два основных способа разрешения коллизий:

<b>Метод цепочек</b>. В этом случае корзина (bucket) может хранить несколько элементов, и хранятся они, в большинстве случаев, в виде связного списка (linked list).

<b>Метод открытой адресации</b>. Здесь, при возникновении коллизии, происходит поиск некоторой свободной ячейки, куда и добавляется очередной элемент.

В Java, для разрешения коллизий, используется метод цепочек.

Изначально, корзина в HashMap представляет из себя связный список (linked list). При возникновении коллизии, очередная пара добавляется в этот список.

В последних версиях JDK, в случае, если размер связного списка становится более 8 (константа TREEIFY_THRESHOLD), то происходит преобразование связного списка в дерево, при этом, найти элемент в HashMap в худшем случае уже можно за O(log(n)), а не за O(n), как в связном списке.
  

# Паттерны проектирования
## Factory

Паттерн Factory используется, когда необхоимо создавать объекты разных типов с помощью одного и того же метода. 

Это очень удобно, когда возникает ситуация, в которой мы не знаем, какой тип нам понадобится.
Например: задача "что нибудь сьесть" - eatRandom

Паттерн Factory позволяет, например, посчитать сколкьо обьектов создано каждого типа конкретной фабрикой.
Считать с помощью Фабрики гораздо удобнее чем, например, создавать статические переменные в каждом классе, а помочь печатать их с помощью отдельного метода. Это и читабельнее, и будет легче править в будущем.
Также с помощью паттерна Factory мы можем генерировать сложные объекты намного проще и с меньшим количеством ошибок.

Например, у нас есть объект с огромным количеством полей:
бОльшая часть этих полей заполняются типично, а часть полей будет заполняться разными значениями.
Таким образом, при создании сложных объектов, мы можем "прятать" весь этот процесс в фабрику. 
Например, если для создания объекта требуются какие-нибудь сложные вычисления или если у объекта очень много параметров, а Вам пока нужен только объект с параметрами по умолчанию.

#Others
<b>Полиморфизм</b> - возможность применения одноименных методов с одинаковыми или различными наборами параметров в одном классе или в группе классов, связанных отношением наследования.
https://vertex-academy.com/tutorials/ru/chto-takoe-polimorfizm-java/

